* 介绍 Introduction
* 工作区, 包和目标  Workspace. Packages and Targets

  * 工作区\(Workspace\)
  * 包\(Packages\)
  * 目标\(Targets\)
  * 标签\(Labels\)
  * 标签规范
  * 规则\(Rules\)

* BUILD文件

  * 核心构建语言
  * 声明构建规则

* 构建规则的类型

* 依赖

  * 实际依赖和声明依赖

  * 依赖类型

  * 使用标签引用目录

# 介绍

Bazel从一个叫做工作区的目录中的源码构建软件, 工作区中的源文件组织在一个嵌套的层次结构中，其中每个包是一个包含一组相关源文件和一个BUILD文件的目录。 BUILD文件指定了从源文件构建出什么 样的软件.

# 工作区, 包和目标\(Workspace, Packages, Targets\)

## 工作区

一个工作区就是一个在你的文件系统中的目录, 它包含了你要构建的软件的源文件, 和包含构建输出目录的链接符号. 每一个工作区包含 了一个叫做WORKSPACE的文本文件, WORKSPACE文件可以是空的, 或者包含了需要的外部依赖的引用.  你可以在构建百科中查看工作区规则 .

## 包

在工作区中,最主要的代码组织单元就是包.  包就是一组相关的文件和它们之间依赖关系的一种规范.

包被定义为一个包含了名叫BUILD文件的目录. 它在工作区目录之下. 包中包含 其目录中的所有文件,以及它下面的所有子目录, 但是其中也包含了BUILD文件的文件夹除外.

例如, 在下面的目录树中, 有两个包: my/app 和子包 my/app/tests. 注意: my/app/data不是一个包, 它是属于包my/app的一个目录

```
src/my/app/BUILD
src/my/app/app.cc
src/my/app/data/input.txt
src/my/app/tests/BUILD
src/my/app/tests/test.cc
```

## 目标

包是一个容器, 组成包的元素叫做目标\(targets\).  大多数目标\(targets\) 属于 文件和规则 . 此外,还有另外一种目标: 包组\(package groups\), 这种目标非常少.

目标层次

文件进一步划分为两种,. 源文件通常由程序员编写并且要提交到代码库中的. 生成的文件, 有时被称做衍生文件, 是由构建工具根据指定的规则生成, 不会被提交到代码库中.

第二种目标就是规则, 规则定义了一系列输入和输出文件之间的关系, 其中最重要的一步就是从输入构建输出.  输出的规则通常是生成文件. 输入的规则一般是源文件, 但有时候输出生成的文件也可以做为一个规则的输入; 所以输出的规则可能是另一个规则的输入. 允许定义一个很长的规则链.

大多数情况下, 一个规则的输入是源文件, 还是生成的文件并不重要, 重要的是文件的内容. 这样使得使用生成的文件替代复杂的源文件变得容易. 例如在某些场景:场当手动维护高度结构化的文件变成一种负担时,我们可能会用程序导出这种文件, 这种文件对使用的人来说不需要修改.  相反如果需要修改可以用源文件轻松的替换生成的文件.

输入的规则可能包含了其它的规则.  这种关系的确切含往往相当复杂. 但直觉上比较简单: C++库的规则A可能用另外一个C++库B的规则作为输入, 这种依赖的影响是在编译期B的头文件对A可用; B的符在链接期间对A可用; B的运行时数据在执行期间对A可用.

对于所有规则, 一个规则生成的文件总是属于和规则相同的包, 不可能将文件生成到另一个包中.  一个包中规则的输入来自另一个包中的规则的情况也不常见.

包组 是用来限制某些规则的访问权限的一组包, 包组使用`package_group`函数定义.它有两个属性:包的列表及其名称.  引用它们的唯一方法是通过规则的`visibility`属性, 或者 package函数的 `defalut_visibility` 属性. 它们不生成或者使用文件, 更多信息,请参考构建百科章节.

## 标签

所有的目标都属于一个包, 包的名称叫做标签. 一个经典的标签的规范形式如下所示:

```
//my/app/main:app_binary
```

每个标签有两部分组成: 包的名称\(my/app/main\)和目标名称\(app\_binary\). 每一个标签唯一标识一个目标.  标签有时以另外一种形式出现, 当冒号省略时. 认为目标的名称与包名的最后一部分相同, 所以下面两个标签是相等的:

```
//my/app
//my/app:app
```

诸如 //my/app 之类的短格式的标签 不能和包名混淆.  标签以 // 开头, 但是包不是. 因此, my/app 是一个包, 并且包含了 //my/app . \(一个常见的误解是//my/app指的是一个包, 或者一个包中的所有目标. 都不对\)

在一个BUILD文件中, 标签中的包名部分可能会省略, 冒号也可能会省略.  所以对于包my/app的BUILD文件的标签\(例如: //my/app:app\)来说, 以下几种 "相对的" 的标签来说是相等的:

```
//my/app:app
//my/app
:app
app
```

\(It is a matter of convention that the colon is omitted for files, but retained for rules, but it is not otherwise significant.\)

类似地，在BUILD文件中，属于该包的文件可能被相对于包目录的未修饰的名称引用:

```
generate.cc
testdata/input.txt
```

对于其它包或者命令行来说, 这些文件目标必须通过完整的标签名引用, 例如:

```
//my/app:generate.cc
```

相对标签不能用于指向其它包中的目标; 在这种情况下必须要指定完整的包名. 例如: 有两个包`my/app`和包`my/app/testdata`\(每个包都有它自已的BUILD文件\), 第二个包中有一个名叫`testdepot.zip`的文件. 这里`//my/app:BUILD`有两种方式引用这个文件\(一个对的,一个错的\):

```
testdata/testdepot.zip  # Wrong: testdata is a different package.
//my/app/testdata:testdepot.zip   # Right.
```

如果错误的使用标签引用`testdepot.zip`文件, 比如 //my/app:testdata/testdept.zip或者//my:app/testdata/testdepot.zip, 构建工具会报"crosses a package boundary"的错误. 因此您应该通过将冒号放在包含最内层的BUILD文件的目录之后来更正标签, 比如: `//my/app/testdata:testdepot.zip`.

## 标签规范

标签的语法是有意设计成的严格的，以便禁止出现对shell有特殊意义的元字符。 这有助于避免非预期的引用问题，并且操作标签时可以更容易地操作构建工具和编写脚本，例如Bazel查询语言。 标签中禁止以下所有内容：任何类型的空白，大括号，括号或括号; 通配符，如 \*;  shell元字符，如＆，\|; 这个列表不全面; 具体细节如下。

#### 目标名称, //... :** **tartget-name

目标名称是目标在包内的名称. 规则的名称是BUILD文件中规则声明中的name参数的值；文件的名称是相对于包含BUILD文件的目录的路径名. 目标名称必须完全由`a-z, A-Z, 0-9` 的字符和标点符号 `_/.+-=~`组成. 不能使用相对路径`..`引用其它包的文件；使用 `//packagename:file`代替. 文件名必须是正常形式的相对路径名，这意味着它们既不能以斜线开头也不能以斜线结尾（例如:` /foo`和`foo/`被禁止），也不得包含多个连续的斜杠作为路径分隔符（例如: `foo// bar`）。类似地，上级引用（`..`）和当前目录引用（`./`）被禁止。 这个规则的唯一例外是目标名称可能完全包含“`.`”。

